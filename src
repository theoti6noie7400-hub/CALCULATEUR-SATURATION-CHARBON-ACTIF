import React, { useMemo, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import {
  AlertTriangle,
  CheckCircle2,
  HelpCircle,
  RefreshCw,
  Copy,
  Sparkles,
} from "lucide-react";

/**
 * Calculateur de saturation du charbon actif
 *
 * Mesure terrain:
 * - On pese le filtre complet (support + charbon) -> poids brut.
 * - Gain (adsorption) = poids_mesure_brut - poids_neuf_brut.
 *
 * Theorie (mono-polluant):
 * - Capacite max (kg) = poids_charbon_net_neuf * capacite_moyenne_polluant.
 * - Saturation (%) = (gain / capacite_max) * 100.
 *
 * Theorie (melange):
 * - Si % connus: avg_mix = somme(part_i * avg_i) (parts normalisees)
 *   capacite_max_mix = charbon_net * avg_mix
 * - Si % inconnus: l'estimation utilise des parts egales.
 * - Pour DECIDER (le plus fiable): conservateur (pire cas)
 *   saturation_conservatrice = max_i( gain / (charbon_net * avg_i) )
 *
 * Seuils (decision):
 * - OK < 70%
 * - A surveiller: 70% a 75%
 * - A remplacer: >= 75%
 * - Sature: >= 100%
 */

// 1) References filtres (poids neuf brut + charbon net neuf)
// Ajout: image optionnelle par reference (a placer dans /public/products/)
const FILTER_REFERENCES = {
  EPUREX_1000: {
    id: "EPUREX_1000",
    label: "CHARBON EPUREX 1000",
    poidsNeufBrutKg: 7.1,
    poidsCharbonNetKg: 5.8,
    image: "/products/epurex1000.jpg",
  },
  EPUREX_MIXTE_HEPA_CH: {
    id: "EPUREX_MIXTE_HEPA_CH",
    label: "CHARBON EPUREX 1000 MIXTE",
    poidsNeufBrutKg: 7.3,
    poidsCharbonNetKg: 3.0,
    image: "/products/epurex1000-mixte.jpg",
  },
  EPUREX_5000_CHARBON: {
    id: "EPUREX_5000_CHARBON",
    label: "CHARBON EPUREX 5000",
    poidsNeufBrutKg: 18.7,
    poidsCharbonNetKg: 12.0,
    image: "/products/epurex5000.jpg",
  },
  CAN_1500: {
    id: "CAN_1500",
    label: "CAN 1500",
    // Neuf brut: 2,0 kg (1,2 kg charbon net + 0,8 kg support)
    poidsNeufBrutKg: 2.0,
    poidsCharbonNetKg: 1.2,
    image: "/products/can1500.jpg",
  },
  PURPLE_1500: {
    id: "PURPLE_1500",
    label: "CAN 1500 PURPLE",
    // Neuf brut: 3,0 kg (2,2 kg charbon net + 0,8 kg support)
    poidsNeufBrutKg: 3.0,
    poidsCharbonNetKg: 2.2,
    image: "/products/can1500-purple.jpg",
  },
  CAN_2600: {
    id: "CAN_2600",
    label: "CAN 2600",
    // Support: 1,4 kg; charbon net: 2,1 kg
    poidsNeufBrutKg: 3.5,
    poidsCharbonNetKg: 2.1,
    image: "/products/can2600.jpg",
  },
  PURPLE_2600: {
    id: "PURPLE_2600",
    label: "CAN 2600 PURPLE",
    // Support: 1,4 kg; charbon net: 3,9 kg
    poidsNeufBrutKg: 5.3,
    poidsCharbonNetKg: 3.9,
    image: "/products/can2600-purple.jpg",
  },
  CAN_9000: {
    id: "CAN_9000",
    label: "CAN 9000",
    // Support: 1,8 kg; charbon net: 2,4 kg
    poidsNeufBrutKg: 4.2,
    poidsCharbonNetKg: 2.4,
    image: "/products/can9000.jpg",
  },
  PURPLE_9000: {
    id: "PURPLE_9000",
    label: "CAN 9000 PURPLE",
    // Support: 1,8 kg; charbon net: 5,2 kg
    poidsNeufBrutKg: 7.0,
    poidsCharbonNetKg: 5.2,
    image: "/products/can9000-purple.jpg",
  },
} as const;

type FilterRef = (typeof FILTER_REFERENCES)[keyof typeof FILTER_REFERENCES];

// 2) Groupes et capacites moyennes
const GROUPS = {
  "1": { label: "Groupe 1 - Tres haute adsorption", avg: 0.35 },
  "2": { label: "Groupe 2 - Forte adsorption", avg: 0.17 },
  "3": { label: "Groupe 3 - Faible adsorption", avg: 0.07 },
  "4": { label: "Groupe 4 - Mauvaise adsorption", avg: 0.0 },
} as const;

type GroupKey = keyof typeof GROUPS; // "1" | "2" | "3" | "4"

type Polluant = {
  // IMPORTANT: inclut le groupe pour ne pas "melanger" des polluants proches
  id: string;
  label: string;
  name: string;
  formula?: string;
  group: GroupKey;
};

function slugifyId(s: string): string {
  return s
    .toLowerCase()
    .replace(/\([^)]*\)/g, "")
    .replace(/\*/g, "")
    .replace(/[^a-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "")
    .slice(0, 60);
}

function parsePolluantLabel(raw: string): {
  name: string;
  formula?: string;
  label: string;
} {
  const cleaned = raw.trim();
  if (!cleaned) return { name: "", label: "" };

  // Split with capture keeps parentheses contents in the array
  const parts = cleaned.split(/\s*\(([^()]*)\)\s*/g).filter((x) => x !== "");

  let base = parts[0]?.trim() ?? cleaned;
  const parens: string[] = [];

  for (let i = 1; i < parts.length; i += 2) {
    parens.push((parts[i] ?? "").trim());
    const tail = (parts[i + 1] ?? "").trim();
    if (tail) base = `${base} ${tail}`.trim();
  }

  const last = parens.length ? parens[parens.length - 1] : undefined;
  const looksLikeFormula = (s?: string) => {
    if (!s) return false;
    return /^[A-Za-z0-9]+$/.test(s) && /[A-Za-z]/.test(s);
  };

  const formula = looksLikeFormula(last) ? last : undefined;
  const nameExtra = formula ? parens.slice(0, -1) : parens;
  const name = nameExtra.length
    ? `${base} (${nameExtra.join(") (")})`.trim()
    : base;
  const label = formula ? `${name} (${formula})` : name;

  return { name, formula, label };
}

// IMPORTANT:
// - Tu as demande "sans rien supprimer" -> on garde toutes les entrees de la source.
// - Et on ne fusionne jamais des polluants de groupes differents.

const POLLUANTS_G1_RAW: string[] = [
  // Ajouts (issus de ta premiere liste)
  "Acetaldehyde (C2H4O)",
  "Acetonenitrile (C3H3NO)",
  "Acetylene (C2H2)",
  "Acetone (C3H6O)",
  "Acrolein (C3H4O)",
  "Alcohol",
  "Amines",
  "Ammonia (NH3)",
  "Anaesthetics",
  "Arsine",
  "Bromhydric acid",

  // Groupe 1 (liste fournie)
  "Acetic acid (vinegar) (C2H4O2)",
  "Acetic anhydride (C4H6O3)",
  "Acrylic acid (acrylate) (C3H4O2)",
  "Acrylonitrile (vinylcyanide) (C3H3N)",
  "Adhesives",
  "Aldrin",
  "Allyl chloride (C3H5Cl)",
  "Aminotoluene",
  "Amyl acetate (isomers) (C7H14O2)",
  "Amyl alcohol (pentanol) (C5H12O)",
  "Amyl ether (C10H22O)",
  "Anniline",
  "Antiseptics",
  "Asphalt fumes",
  "Benzaldehyde",
  "Benzene (C6H6)",
  "Benzine",
  "Benzol",
  "Benzyl alcohol",
  "Benzyl chloride",
  "Bromine (Br2)",
  "Bromofluoromethane",
  "Bromoform",
  "Butaanzuur (Boterzuur)",
  "Butanone (MEK) (C4H8O)",
  "Butyl acetate (C6H12O2)",
  "Butyl alcohol (butanol) (C4H10O)",
  "Butyl cellosolve (C6H14O2)",
  "Butyl chloride (C14H9Cl)",
  "Butyl ether (C818O)",
  "Butyl glycol",
  "Butyl mercaptan",
  "Butyraldehyde (C4H8O)",
  "Butryic acid (C4H8O2)",
  "Camphor (C10H16O)",
  "Caproaldehyde",
  "Caprylic acid (C8H16O2)",
  "Carbolic acid (phenol) (C6H6O)",
  "Carbon disulfide (CS2)",
  "Carbon tetrachloride (CCl4)",
  "Cellosolve",
  "Cellosolve acetate (C6H12O)",
  "Chlorobenzene (phenylchloride) (Cl2)",
  "Chlorobutadiene (chloroprene) (C6H5Cl)",
  "Chloroform (trichloromethane) (CHCl3)",
  "Chloronitropropane (C3H6ClNO2)",
  "Chlorpicrine (CCl3NO2)",
  "Cigarette odor",
  "Citrus fruits",
  "Cleaning compounds",
  "Cooking odors",
  "Creosote",
  "Cresol (C21H24O3)",
  "Crotonaldehyde",
  "Cumene",
  "Cyclohexane (C6H12)",
  "Cyclohexanol (C6H12O)",
  "Cyclohexanone (C6H10O)",
  "Cyclohexene (C6H10)",
  "Cyclopentadiene",
  "Decane of higher hydrocarbons (C10H22)",
  "Degreasing Solvents",
  "Dichloro ethyl ether (C4H8Cl2O)",
  "Dichlorobenzene (C6H4Cl2)",
  "Dichloro-difloro-ethane",
  "Dichloro-difluoro-methane (CCl2F2)",
  "Dichloroethane (C2H4Cl2)",
  "Dichloroethylene (C2H2Cl2)",
  "Dichloronitroethane (C2H3Cl2NO2)",
  "Dichloroproane (C3H6Cl2)",
  "Dichlorotetrafluoro-ethane (C2ClF4)",
  "Diesel fumes",
  "Diethyl aceton",
  "Diethyl aniline",
  "Diethyl disulfide",
  "Dimethyl aniline (C8H11N)",
  "Dimethyl disulfide",
  "Dimethyl formamide",
  "Dimethyl sulfate (C2H6O4S)",
  "Fish/food/fruit odors",
  "Furfural",
  "Gasoline",
  "Glycerol",
  "Glyceryl triacetate",
  "Glycol",
  "Glycol chlorohydrine",
  "Heptane (C7H16)",
  "Heptylene (C7H14)",
  "Hexanol (C6H14O)",
  "Hexamethylene diisocyanate",
  "Hexanone (MIBK) (C6H12O)",
  "Hexyne",
  "Hospital odors",
  "Human odors",
  "Kerosine",
  "Kerosene",
  "Kitchen odors",
  "Lactic acid (C3H6O3)",
  "Leather",
  "Lubricating oils & greases",
  "Lysol",
  "Menthol (C10H20O)",
  "Mercaptans (large molecules) (C2H6S)",
  "N-amyl ether",
  "N-butanol",
  "N-propanol",
  "Naphta(lene) (C10H8)",
  "Naphtalene diisocyanate",
  "Nicotine (C10H14N2)",
  "Nitrobenzene (C6H5NO2)",
  "Nitroethane (C2H5NO2)",
  "Nitropropane (C3H7NO2)",
  "Nitrotoluene (C7H7NO2)",
  "Nonanes",
  "O-dichlorbenzene",
  "Octane (C8H18)",
  "Octene (C8H16)",
  "Oil fumes",
  "Ozone (O3)",
  "P-phenylene diamine",
  "Palamatic",
  "Palamatic acid (C16H32O2)",
  "Pyridine",
  "Rancid oils and fats",
  "Resins",
  "Rubber",
  "Silicon tetrachloride",
  "Stale odors",
  "Stable odors",
  "Styrene",
  "Stryene monomer (C8H8)",
  "Sulfuric anhydride",
  "Sulfurous compounds",
  "Tar fumes",
  "Tetrachloroethane (C2H2Cl4)",
  "Tetrachloroethene",
  "Tetrachloroethylene perchloroethylene (C2Cl4)",
  "Tetrahydrothiphene",
  "Tetrahydrofuran (C4H8O)",
  "Thiophene (C4H4S)",
  "Toilet odors",
  "Tolud",
  "Toluene (C7H8)",
  "Toluene diisocyanate (C9H6N2O)",
  "Toluidine",
  "Trichloroethane (C2H3Cl3)",
  "Trichloroethylene (C2HCl3)",
  "Triethanolamine",
  "Trimethylbenzeneallinsomers",
  "Trimethylphosphite",
  "Thrimethylhexamethylene diisocyanate",
  "Turpentine",
  "Undecane",
  "Urea (CH4N2O)",
  "Uric acid (C5H4N4O3)",
  "Valeric acid (C5H10O2)",
  "Valeric aldehyde (C5H10O)",
  "Varnish odors",
  "Ventilation systems",
  "Vinegar (acetic acid)",
];

const POLLUANTS_G2_RAW: string[] = [
  "Acetone (C3H6O)",
  "Acrolein (C3H4O)",
  "Arsine",
  "Blood odor",
  "Butadiene (C4H6)",
  "Butanal",
  "Carbon bisulphide",
  "Chlorine (Cl2)",
  "Chloromethane (methylchloride) (CH3Cl)",
  "Combustion odors",
  "Cyanides incl. Hydrogen Cyanide",
  "Deodorizers",
  "Ethyl alcohol (C2H6O)",
  "Ethyl amine",
  "Ethyl ether",
  "Ethyl formate (C3H6O2)",
  "Formaldehyde",
  "Forrmic acid (CH2O2)",
  "I-valeric acid",
  "Isobutaan",
  "Isoprene",
  "Isopropanol",
  "Methanal",
  "Methyl acetate (C3H6O2)",
  "Methyl bromide (CH3Br)",
  "Methyl chloride (CH3Cl)",
  "Methyl cyanide",
  "Methyl formate (C4H4O2)",
  "Methylal",
  "Nitromethane (CH3NO2)",
  "Pentane (C5H12)",
  "Pentene (C5H10)",
  "Pentyne (C5H8)",
  "Phosgene (CCl2O)",
  "Products of incomplete combustions",
  "Propanal",
  "Propionaldehyde",
  "Propionic acid (C3H6O2)",
  "Propionic aldehyde",
  "Propyl aldehyde (C3H6O)",
  "Propylene",
  "Sewer odors",
  "Slaughter odors",
  "Sludge odor",
  "Solvents",
  "Sulfur dichloride",
  "Toxic gases",
  "Valeric",
];

const POLLUANTS_G3_RAW: string[] = [
  "Acetaldehyde (C2H4O)",
  "Acetonenitrile (C3H3NO)",
  "Acetylene (C2H2)",
  "Alcohol",
  "Amines",
  "Bromhydric acid",
  "Butane (C4H10)",
  "Butene",
  "Butylene/butane (C4H8)",
  "Butyne",
  "Carbon dioxide (CO2)",
  "Carbonyl sulfide",
  "Corrosive gases",
  "Ethylene oxide (C2H4O)",
  "Fluortrichlormethane",
  "Hydrogen fluoride (FH)",
  "Hydrogen selenide (H2Se)",
  "Hydrogen sulfide (H2S)",
  "Methanol",
  "Methyl mercaptan (C6H12O)",
  "Sulfur dioxide (SO2)",
  "Sulfur gas",
  "Sulfur trioxide (SO3)",
  "Sulfuric acid (H2SO4)",
  "Tabacco smoke",
  "Trimethylanime",
  "Trifluorobromomethane",
];

const POLLUANTS_G4_RAW: string[] = [
  "Ammonia (NH3)",
  "Carbon monoxide (CO)",
  "Carbonic acid",
  "Ethane (C2H6)",
  "Ethylene (C2H4)",
  "Hydrogen (H2)",
  "Hydrogen cyanide (HCN)",
  "Mercury fumes (Hg)",
  "Methane (CH4)",
  "Octylene",
];

function buildPolluants(raw: string[], group: GroupKey): Polluant[] {
  return raw
    .map((r) => r.trim())
    .filter(Boolean)
    .map((r) => {
      const { name, formula, label } = parsePolluantLabel(r);
      const id = `${slugifyId(label)}__g${group}`;
      return { id, label, name, formula, group };
    });
}

// Polluants triés: d'abord groupe, puis ordre alphabétique (case-insensitive)
const POLLUANTS: Polluant[] = [
  ...buildPolluants(POLLUANTS_G1_RAW, "1"),
  ...buildPolluants(POLLUANTS_G2_RAW, "2"),
  ...buildPolluants(POLLUANTS_G3_RAW, "3"),
  ...buildPolluants(POLLUANTS_G4_RAW, "4"),
].sort((a, b) =>
  a.group === b.group
    ? a.label.localeCompare(b.label, "en", { sensitivity: "base" })
    : Number(a.group) - Number(b.group)
);

// --- Deduce duplicate names across groups (for UI clarity) ---
const DUPLICATE_NAMES = (() => {
  const counts = new Map<string, number>();
  for (const p of POLLUANTS) {
    counts.set(p.name, (counts.get(p.name) ?? 0) + 1);
  }
  return new Set<string>(
    [...counts.entries()].filter(([, c]) => c > 1).map(([n]) => n)
  );
})();

function displayPolluant(p: Polluant): string {
  // If same "name" exists in multiple groups, always suffix with the group label.
  if (!DUPLICATE_NAMES.has(p.name)) return p.label;
  return `${p.label} — ${GROUPS[p.group].label}`;
}

// --- Lightweight tests (console.assert) ---
(function selfTest() {
  console.assert(POLLUANTS.length > 50, "Expected many polluants to be loaded.");
  console.assert(POLLUANTS.some((x) => x.id.endsWith("__g1")), "Expected group 1 ids.");
  console.assert(POLLUANTS.some((x) => x.id.endsWith("__g2")), "Expected group 2 ids.");
  console.assert(POLLUANTS.some((x) => x.id.endsWith("__g3")), "Expected group 3 ids.");
  console.assert(POLLUANTS.some((x) => x.id.endsWith("__g4")), "Expected group 4 ids.");

  const p2 = parsePolluantLabel("Acetic acid (vinegar) (C2H4O2)");
  console.assert(p2.formula === "C2H4O2", "Expected last parentheses as formula.");

  // Duplicate detection sanity (NH3 appears in at least two groups in provided data)
  const nh3 = POLLUANTS.filter(
    (p) => p.label.includes("Ammonia") && (p.formula ?? "").includes("NH3")
  );
  console.assert(
    nh3.length >= 2,
    "Expected NH3 to appear at least twice (different groups)."
  );

  // Extra: verify sorting within same group
  const g1 = POLLUANTS.filter((p) => p.group === "1").map((p) => p.label);
  for (let i = 1; i < g1.length; i++) {
    console.assert(
      g1[i - 1].localeCompare(g1[i], "en", { sensitivity: "base" }) <= 0,
      "Group 1 should be sorted."
    );
  }

  // References photos: optional, but should not crash if missing
  const refs = Object.values(FILTER_REFERENCES);
  console.assert(refs.length >= 6, "Expected filter references.");
})();

function clamp(n: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, n));
}

function formatKg(x: number): string {
  if (!Number.isFinite(x)) return "-";
  return `${x.toFixed(2)} kg`;
}

function formatPct(x: number): string {
  if (!Number.isFinite(x)) return "-";
  return `${x.toFixed(0)} %`;
}

function parseNumberLoose(s: string): number {
  const v = Number(String(s ?? "").trim().replace(",", "."));
  return Number.isFinite(v) ? v : NaN;
}

type SaturationResult = {
  capaciteMaxKg: number;
  saturationPct: number;
  avgUsed: number;
};

function calcMonoSaturation(
  gainKg: number,
  charbonNetKg: number,
  groupAvg: number
): SaturationResult {
  const capaciteMaxKg = charbonNetKg * groupAvg;
  const saturationPct =
    Number.isFinite(gainKg) &&
    Number.isFinite(capaciteMaxKg) &&
    capaciteMaxKg > 0
      ? (gainKg / capaciteMaxKg) * 100
      : NaN;
  return { capaciteMaxKg, saturationPct, avgUsed: groupAvg };
}

function calcMixSaturation(
  gainKg: number,
  charbonNetKg: number,
  items: { avg: number; share01?: number }[]
): { estimated: SaturationResult; conservative: SaturationResult } {
  const valid = items.filter((x) => Number.isFinite(x.avg) && x.avg >= 0);
  const nonZero = valid.filter((x) => x.avg > 0);

  // Conservative: worst-case among selected pollutants with avg>0
  let worstPct = NaN;
  let worstAvg = NaN;
  for (const x of nonZero) {
    const r = calcMonoSaturation(gainKg, charbonNetKg, x.avg);
    if (!Number.isFinite(r.saturationPct)) continue;
    if (!Number.isFinite(worstPct) || r.saturationPct > worstPct) {
      worstPct = r.saturationPct;
      worstAvg = x.avg;
    }
  }
  const conservative: SaturationResult = {
    capaciteMaxKg: Number.isFinite(worstAvg) ? charbonNetKg * worstAvg : NaN,
    saturationPct: worstPct,
    avgUsed: worstAvg,
  };

  // Estimated: if user provided shares, use weighted average; else equal shares
  const shares = valid.map((x) =>
    Number.isFinite(x.share01 ?? NaN) ? (x.share01 as number) : NaN
  );
  const sumShares = shares.reduce(
    (acc, v) => (Number.isFinite(v) ? acc + v : acc),
    0
  );

  let avgMix = NaN;
  if (valid.length === 0) {
    avgMix = NaN;
  } else if (sumShares > 0) {
    avgMix = valid.reduce((acc, x, i) => {
      const w = Number.isFinite(shares[i]) ? (shares[i] as number) / sumShares : 0;
      return acc + w * x.avg;
    }, 0);
  } else {
    const w = 1 / valid.length;
    avgMix = valid.reduce((acc, x) => acc + w * x.avg, 0);
  }

  const estimated = calcMonoSaturation(gainKg, charbonNetKg, avgMix);
  return { estimated, conservative };
}

// --- Mix math tests (should run once per module evaluation) ---
(function mixMathTests() {
  const gainKg = 1;
  const charbon = 10;
  const a = 0.35;
  const b = 0.07;
  const r = calcMixSaturation(gainKg, charbon, [
    { avg: a, share01: 0.5 },
    { avg: b, share01: 0.5 },
  ]);
  console.assert(Math.abs(r.estimated.avgUsed - 0.21) < 1e-9, "Mix avg should be weighted.");
  console.assert(Math.abs(r.estimated.capaciteMaxKg - 2.1) < 1e-9, "Mix capacity should match.");
  console.assert(
    Number.isFinite(r.conservative.saturationPct) && Number.isFinite(r.estimated.saturationPct)
      ? r.conservative.saturationPct >= r.estimated.saturationPct
      : true,
    "Conservative should be >= estimated."
  );

  // Extra: if all avgs are 0, conservative should be NaN
  const r2 = calcMixSaturation(1, 10, [{ avg: 0 }, { avg: 0 }]);
  console.assert(!Number.isFinite(r2.conservative.saturationPct), "Conservative should be NaN when no adsorption.");
})();

function statusFromSaturation(satPct: number) {
  if (!Number.isFinite(satPct)) {
    return { label: "-", tone: "secondary" as const, icon: HelpCircle };
  }
  if (satPct >= 100) {
    return { label: "Sature", tone: "destructive" as const, icon: AlertTriangle };
  }
  if (satPct >= 75) {
    return { label: "A remplacer", tone: "destructive" as const, icon: AlertTriangle };
  }
  if (satPct >= 70) {
    return { label: "A surveiller", tone: "outline" as const, icon: AlertTriangle };
  }
  return { label: "OK", tone: "default" as const, icon: CheckCircle2 };
}

type ModePolluant = "mono" | "melange";

type MixItem = {
  polluantId: string;
  // % du flux / de la charge (optionnel). Si vide -> parts egales.
  sharePct: string;
};

type MixPreset = {
  id: string;
  label: string;
  // list of group keys, repeated means "higher importance" when auto building a mix
  groups: GroupKey[];
  note: string;
};

const MIX_PRESETS: MixPreset[] = [
  {
    id: "solvants_peinture",
    label: "Solvants / peinture / vernis",
    groups: ["1", "1", "2", "2", "2"],
    note: "Profil oriente solvants et VOC (forte charge).",
  },
  {
    id: "colles_resines",
    label: "Colles / resines",
    groups: ["1", "1", "1", "2"],
    note: "Tres haute adsorption attendue (odeurs fortes).",
  },
  {
    id: "diesel_essence",
    label: "Diesel / essence / carburants",
    groups: ["1", "1", "2"],
    note: "Hydrocarbures + odeurs carburant.",
  },
  {
    id: "fumee_combustion",
    label: "Fumee / combustion",
    groups: ["2", "2", "3"],
    note: "Produits de combustion, odeurs persistantes.",
  },
  {
    id: "cuisine_odeurs",
    label: "Cuisine / graisses / odeurs alimentaires",
    groups: ["1", "1", "2"],
    note: "Odeurs organiques souvent bien adsorbees.",
  },
  {
    id: "tabac",
    label: "Tabac",
    groups: ["1", "2", "3"],
    note: "Melange d'odeurs et composes divers.",
  },
  {
    id: "hopital",
    label: "Milieu hospitalier",
    groups: ["1", "2"],
    note: "Odeurs complexes (desinfectants, solvants).",
  },
  {
    id: "atelier_general",
    label: "Atelier / industrie (general)",
    groups: ["1", "2", "2", "3"],
    note: "Profil polyvalent si la source exacte est inconnue.",
  },
  {
    id: "gaz_difficiles",
    label: "Gaz difficiles (ex: NH3 / H2S)",
    groups: ["4", "3"],
    note: "Attention: charbon standard parfois inefficace. Utiliser un media adapte.",
  },
];

function pickRepresentativePolluantsForGroups(groups: GroupKey[], pool: Polluant[]): Polluant[] {
  const byGroup: Record<GroupKey, Polluant[]> = {
    "1": pool.filter((p) => p.group === "1"),
    "2": pool.filter((p) => p.group === "2"),
    "3": pool.filter((p) => p.group === "3"),
    "4": pool.filter((p) => p.group === "4"),
  };

  const idx: Record<GroupKey, number> = { "1": 0, "2": 0, "3": 0, "4": 0 };
  const out: Polluant[] = [];

  for (const g of groups) {
    const list = byGroup[g];
    if (list.length === 0) continue;
    const i = idx[g] % list.length;
    out.push(list[i]);
    idx[g] += 1;
  }

  // Ensure uniqueness by id
  const seen = new Set<string>();
  return out.filter((p) => {
    if (seen.has(p.id)) return false;
    seen.add(p.id);
    return true;
  });
}

function buildReportText(args: {
  dateIso: string;
  dateClient?: string;
  clientName?: string;
  operatorName?: string;
  deviceSerial?: string;
  mode: ModePolluant;
  reference: FilterRef;
  polluants: Polluant[];
  shares: (string | undefined)[];
  poidsMesureKg: number;
  gainKg: number;
  charbonNetKg: number;
  supportKg: number;
  resultDecision: { capaciteMaxKg: number; saturationPct: number };
  resultEstimated?: { capaciteMaxKg: number; saturationPct: number; avgUsed: number };
  resultConservative?: { capaciteMaxKg: number; saturationPct: number; avgUsed: number };
  humidite?: number;
  temperature?: number;
}): string {
  const lines: string[] = [];
  lines.push("RAPPORT - Saturation charbon actif");

  const dateLine = args.dateClient && args.dateClient.trim() ? args.dateClient.trim() : args.dateIso;
  lines.push(`Date: ${dateLine}`);
  if (args.clientName && args.clientName.trim()) lines.push(`Client: ${args.clientName.trim()}`);
  if (args.operatorName && args.operatorName.trim()) lines.push(`Operateur: ${args.operatorName.trim()}`);
  if (args.deviceSerial && args.deviceSerial.trim()) lines.push(`SN appareil: ${args.deviceSerial.trim()}`);

  lines.push("---");
  lines.push(`Reference: ${args.reference.label}`);
  lines.push(`Poids neuf brut: ${args.reference.poidsNeufBrutKg.toFixed(2)} kg`);
  lines.push(`Charbon net (neuf): ${args.charbonNetKg.toFixed(2)} kg`);
  lines.push(`Support (estime): ${args.supportKg.toFixed(2)} kg`);
  lines.push(`Poids brut mesure: ${Number.isFinite(args.poidsMesureKg) ? args.poidsMesureKg.toFixed(2) : "-"} kg`);
  lines.push(`Gain (adsorption): ${Number.isFinite(args.gainKg) ? args.gainKg.toFixed(2) : "-"} kg`);
  if (Number.isFinite(args.humidite ?? NaN)) lines.push(`Humidite: ${(args.humidite as number).toFixed(0)} %`);
  if (Number.isFinite(args.temperature ?? NaN)) lines.push(`Temperature: ${(args.temperature as number).toFixed(0)} C`);

  lines.push("---");
  lines.push(`Mode: ${args.mode === "mono" ? "1 polluant" : "Melange"}`);

  args.polluants.forEach((p, i) => {
    const share = args.shares[i];
    const shareTxt = share && share.trim() ? ` (${share.trim()}%)` : "";
    lines.push(`- ${displayPolluant(p)}${shareTxt}`);
  });

  lines.push("---");
  lines.push("RESULTAT (decision)");
  lines.push(`Capacite max utilisee: ${Number.isFinite(args.resultDecision.capaciteMaxKg) ? args.resultDecision.capaciteMaxKg.toFixed(2) : "-"} kg`);
  lines.push(`Saturation (decision): ${Number.isFinite(args.resultDecision.saturationPct) ? args.resultDecision.saturationPct.toFixed(0) : "-"} %`);

  if (args.mode === "melange" && args.resultEstimated && args.resultConservative) {
    lines.push("---");
    lines.push("DETAILS MELANGE");
    lines.push(`Estimation: ${Number.isFinite(args.resultEstimated.saturationPct) ? args.resultEstimated.saturationPct.toFixed(0) : "-"} % (avg ${(args.resultEstimated.avgUsed * 100).toFixed(1)}%)`);
    lines.push(`Conservateur: ${Number.isFinite(args.resultConservative.saturationPct) ? args.resultConservative.saturationPct.toFixed(0) : "-"} % (avg ${(args.resultConservative.avgUsed * 100).toFixed(1)}%)`);
  }

  lines.push("---");
  lines.push("Seuils: OK < 70% | Surveiller 70-75% | Remplacer >= 75% | Sature >= 100%");
  return lines.join("\n");
}

function isSecureClipboardAvailable(): boolean {
  try {
    return (
      typeof window !== "undefined" &&
      (window.isSecureContext ?? false) &&
      typeof navigator !== "undefined" &&
      !!(navigator as any).clipboard &&
      typeof (navigator as any).clipboard.writeText === "function"
    );
  } catch {
    return false;
  }
}

async function tryCopyText(text: string): Promise<boolean> {
  // Preferred: Clipboard API (requires secure context + permission)
  if (isSecureClipboardAvailable()) {
    try {
      await (navigator as any).clipboard.writeText(text);
      return true;
    } catch {
      // fallthrough
    }
  }

  // Fallback: execCommand (works in many embedded / sandboxed contexts)
  try {
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.setAttribute("readonly", "");
    ta.style.position = "fixed";
    ta.style.top = "-9999px";
    ta.style.left = "-9999px";
    document.body.appendChild(ta);
    ta.select();
    ta.setSelectionRange(0, ta.value.length);
    const ok = document.execCommand("copy");
    document.body.removeChild(ta);
    return ok;
  } catch {
    return false;
  }
}

function ImageThumb({ src, alt, size = 44 }: { src?: string; alt: string; size?: number }) {
  if (!src) return null;
  return (
    <img
      src={src}
      alt={alt}
      className="rounded-xl border object-cover bg-background"
      style={{ width: size, height: size }}
      onError={(e) => {
        // si l'image n'existe pas encore, on masque proprement
        (e.currentTarget as HTMLImageElement).style.display = "none";
      }}
    />
  );
}

export default function CalculateurSaturationCharbonActif() {
  const [filterId, setFilterId] = useState<FilterRef["id"]>(
    FILTER_REFERENCES.EPUREX_1000.id
  );
  const [mode, setMode] = useState<ModePolluant>("mono");

  // Mono
  const [polluantId, setPolluantId] = useState<string>(POLLUANTS[0]?.id ?? "");

  // Recherche commune
  const [polluantSearch, setPolluantSearch] = useState<string>("");
  const [groupFilter, setGroupFilter] = useState<GroupKey | "ALL">("ALL");

  // "Je ne sais pas" preset
  const [mixPresetId, setMixPresetId] = useState<string>(MIX_PRESETS[0]?.id ?? "");

  // Melange
  const [mixItems, setMixItems] = useState<MixItem[]>([
    { polluantId: POLLUANTS[0]?.id ?? "", sharePct: "" },
    { polluantId: POLLUANTS[1]?.id ?? POLLUANTS[0]?.id ?? "", sharePct: "" },
  ]);

  const [poidsMesureStr, setPoidsMesureStr] = useState<string>("");
  const [humiditeStr, setHumiditeStr] = useState<string>("");
  const [temperatureStr, setTemperatureStr] = useState<string>("");

  // Champs rapport (optionnels)
  const [clientName, setClientName] = useState<string>("");
  const [operatorName, setOperatorName] = useState<string>("");
  const [deviceSerial, setDeviceSerial] = useState<string>("");
  const [reportDate, setReportDate] = useState<string>("");

  // Rapport
  const [copiedState, setCopiedState] = useState<"idle" | "copied" | "failed">(
    "idle"
  );
  const [reportPreview, setReportPreview] = useState<string>("");
  const [showReportPreview, setShowReportPreview] = useState<boolean>(false);

  const filter = useMemo(() => {
    const f = Object.values(FILTER_REFERENCES).find((x) => x.id === filterId);
    return f ?? FILTER_REFERENCES.EPUREX_1000;
  }, [filterId]);

  const supportKg = useMemo(() => {
    const s = filter.poidsNeufBrutKg - filter.poidsCharbonNetKg;
    return Number.isFinite(s) ? Math.max(0, s) : NaN;
  }, [filter.poidsNeufBrutKg, filter.poidsCharbonNetKg]);

  const polluant = useMemo(() => {
    return POLLUANTS.find((p) => p.id === polluantId) ?? POLLUANTS[0];
  }, [polluantId]);

  const filteredPolluants = useMemo(() => {
    const q = polluantSearch.trim();
    const norm = (s: string) =>
      s
        .toLowerCase()
        .replace(/\([^)]*\)/g, "")
        .replace(/[^a-z0-9]+/g, " ")
        .trim();

    const base =
      groupFilter === "ALL"
        ? POLLUANTS
        : POLLUANTS.filter((p) => p.group === groupFilter);
    if (!q) return base;
    const nq = norm(q);
    return base.filter(
      (p) =>
        norm(p.label).includes(nq) ||
        norm(p.name).includes(nq) ||
        norm(GROUPS[p.group].label).includes(nq)
    );
  }, [polluantSearch, groupFilter]);

  const poidsMesure = useMemo(
    () => parseNumberLoose(poidsMesureStr),
    [poidsMesureStr]
  );
  const humidite = useMemo(() => parseNumberLoose(humiditeStr), [humiditeStr]);
  const temperature = useMemo(
    () => parseNumberLoose(temperatureStr),
    [temperatureStr]
  );

  const gain = useMemo(() => {
    if (!Number.isFinite(poidsMesure)) return NaN;
    return poidsMesure - filter.poidsNeufBrutKg;
  }, [poidsMesure, filter.poidsNeufBrutKg]);

  const monoResult = useMemo(() => {
    const g = GROUPS[polluant.group];
    return calcMonoSaturation(gain, filter.poidsCharbonNetKg, g.avg);
  }, [gain, filter.poidsCharbonNetKg, polluant.group]);

  const mixResult = useMemo(() => {
    const items = mixItems
      .map((it) => {
        const p = POLLUANTS.find((x) => x.id === it.polluantId);
        const avg = p ? GROUPS[p.group].avg : NaN;
        const sharePct = parseNumberLoose(it.sharePct);
        return {
          avg,
          share01: Number.isFinite(sharePct) ? sharePct / 100 : undefined,
        };
      })
      .filter((x) => Number.isFinite(x.avg));

    return calcMixSaturation(gain, filter.poidsCharbonNetKg, items);
  }, [mixItems, gain, filter.poidsCharbonNetKg]);

  // Choix "fiable": on base la decision sur le conservateur en melange.
  const activeCapaciteMax =
    mode === "mono" ? monoResult.capaciteMaxKg : mixResult.conservative.capaciteMaxKg;
  const activeSaturation =
    mode === "mono" ? monoResult.saturationPct : mixResult.conservative.saturationPct;

  const saturationClamped = useMemo(() => {
    return Number.isFinite(activeSaturation)
      ? clamp(activeSaturation, 0, 500)
      : NaN;
  }, [activeSaturation]);

  const status = statusFromSaturation(saturationClamped);
  const StatusIcon = status.icon;

  const warnings = useMemo(() => {
    const w: string[] = [];
    if (Number.isFinite(humidite) && humidite > 70) {
      w.push("Humidite > 70% : adsorption potentiellement degradee.");
    }
    if (Number.isFinite(temperature) && temperature > 60) {
      w.push("Temperature > 60C : adsorption potentiellement degradee.");
    }
    if (Number.isFinite(gain) && gain < 0) {
      w.push("Poids mesure inferieur au poids neuf : verifier la saisie ou l'etat du filtre.");
    }

    if (
      Number.isFinite(gain) &&
      Number.isFinite(activeCapaciteMax) &&
      activeCapaciteMax > 0
    ) {
      const pct = (gain / activeCapaciteMax) * 100;
      if (pct > 250) {
        w.push("Saturation > 250% : possible erreur de saisie (kg/g) ou mesure.");
      }
    }

    if (mode === "mono") {
      if (polluant.group === "4") {
        w.push(
          "Polluant groupe 4 : adsorption nulle ou quasi nulle (calcul % peu pertinent)."
        );
      }
      if (DUPLICATE_NAMES.has(polluant.name)) {
        w.push(
          "Ce polluant existe dans plusieurs groupes dans la doc. Verifier le type de charbon (standard vs impregne/traite)."
        );
      }
    } else {
      const selectedPolluants = mixItems
        .map((it) => POLLUANTS.find((p) => p.id === it.polluantId))
        .filter(Boolean) as Polluant[];

      if (selectedPolluants.some((p) => p.group === "4")) {
        w.push(
          "Melange contient un polluant groupe 4 : la decision est basee sur un calcul conservateur. Si ce polluant domine, le charbon standard peut etre inefficace."
        );
      }
      const anyShare = mixItems.some((it) => it.sharePct.trim().length > 0);
      if (!anyShare) {
        w.push(
          "Proportions melange non renseignees : estimation a parts egales + decision conservatrice (pire cas)."
        );
      }
    }

    return w;
  }, [humidite, temperature, gain, mode, polluant.group, polluant.name, mixItems, activeCapaciteMax]);

  const polluantsForSelect = useMemo(() => {
    return groupFilter === "ALL" ? POLLUANTS : POLLUANTS.filter((p) => p.group === groupFilter);
  }, [groupFilter]);

  const reset = () => {
    setFilterId(FILTER_REFERENCES.EPUREX_1000.id);
    setMode("mono");
    setPolluantId(POLLUANTS[0]?.id ?? "");
    setPolluantSearch("");
    setGroupFilter("ALL");
    setMixPresetId(MIX_PRESETS[0]?.id ?? "");
    setMixItems([
      { polluantId: POLLUANTS[0]?.id ?? "", sharePct: "" },
      { polluantId: POLLUANTS[1]?.id ?? POLLUANTS[0]?.id ?? "", sharePct: "" },
    ]);
    setPoidsMesureStr("");
    setHumiditeStr("");
    setTemperatureStr("");
    setClientName("");
    setOperatorName("");
    setDeviceSerial("");
    setReportDate("");
    setCopiedState("idle");
    setReportPreview("");
    setShowReportPreview(false);
  };

  const applyPreset = () => {
    const preset = MIX_PRESETS.find((p) => p.id === mixPresetId) ?? MIX_PRESETS[0];
    const picked = pickRepresentativePolluantsForGroups(preset.groups, POLLUANTS);
    if (picked.length === 0) return;
    setMode("melange");
    setMixItems(picked.map((p) => ({ polluantId: p.id, sharePct: "" })));
    setPolluantSearch("");
    setGroupFilter("ALL");
  };

  const buildCurrentReport = () => {
    const dateIso = new Date().toISOString();

    const polluants =
      mode === "mono"
        ? [polluant]
        : (mixItems
            .map((it) => POLLUANTS.find((p) => p.id === it.polluantId))
            .filter(Boolean) as Polluant[]);

    const shares = mode === "mono" ? [undefined] : mixItems.map((it) => it.sharePct);

    return buildReportText({
      dateIso,
      dateClient: reportDate,
      clientName,
      operatorName,
      deviceSerial,
      mode,
      reference: filter,
      polluants,
      shares,
      poidsMesureKg: poidsMesure,
      gainKg: gain,
      charbonNetKg: filter.poidsCharbonNetKg,
      supportKg,
      resultDecision: {
        capaciteMaxKg: activeCapaciteMax,
        saturationPct: saturationClamped,
      },
      resultEstimated:
        mode === "melange"
          ? {
              capaciteMaxKg: mixResult.estimated.capaciteMaxKg,
              saturationPct: clamp(mixResult.estimated.saturationPct, 0, 500),
              avgUsed: mixResult.estimated.avgUsed,
            }
          : undefined,
      resultConservative:
        mode === "melange"
          ? {
              capaciteMaxKg: mixResult.conservative.capaciteMaxKg,
              saturationPct: clamp(mixResult.conservative.saturationPct, 0, 500),
              avgUsed: mixResult.conservative.avgUsed,
            }
          : undefined,
      humidite,
      temperature,
    });
  };

  const copyReport = async () => {
    const report = buildCurrentReport();
    setReportPreview(report);
    setCopiedState("idle");
    setShowReportPreview(false);

    const ok = await tryCopyText(report);
    if (ok) {
      setCopiedState("copied");
      setShowReportPreview(false);
      window.setTimeout(() => setCopiedState("idle"), 2500);
    } else {
      setCopiedState("failed");
      setShowReportPreview(true);
    }
  };

  return (
    <div className="min-h-screen w-full bg-background p-4 md:p-8">
      <div className="mx-auto max-w-3xl space-y-4">
        <div className="flex flex-col gap-2">
          <h1 className="text-2xl md:text-3xl font-semibold tracking-tight">
            Calculateur de saturation du charbon actif
          </h1>
          <p className="text-sm text-muted-foreground">
            Selectionne le polluant (ou melange), la reference, puis saisis le poids brut mesure.
          </p>
        </div>

        {showReportPreview && (
          <Card className="rounded-2xl shadow-sm">
            <CardContent className="p-4 md:p-6 space-y-3">
              <div className="flex items-center justify-between gap-2">
                <div className="text-sm font-medium">Rapport (copie manuelle)</div>
                <Button
                  type="button"
                  variant="outline"
                  className="rounded-2xl"
                  onClick={async () => {
                    const ok = await tryCopyText(reportPreview);
                    setCopiedState(ok ? "copied" : "failed");
                    if (ok) setShowReportPreview(false);
                  }}
                >
                  <Copy className="h-4 w-4 mr-2" />
                  Retenter copie
                </Button>
              </div>
              <div className="text-xs text-muted-foreground">
                Si la copie automatique est bloquee, clique dans le champ (selectionne tout), puis Ctrl+C.
              </div>
              <textarea
                className="w-full min-h-[220px] rounded-2xl border bg-background p-3 text-xs"
                value={reportPreview}
                readOnly
                onFocus={(e) => e.currentTarget.select()}
              />
            </CardContent>
          </Card>
        )}

        <Card className="rounded-2xl shadow-sm">
          <CardContent className="p-4 md:p-6 space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label>Reference filtre</Label>
                <Select value={filterId} onValueChange={(v) => setFilterId(v as any)}>
                  <SelectTrigger className="rounded-2xl">
                    <SelectValue placeholder="Selectionner une reference" />
                  </SelectTrigger>
                  <SelectContent>
                    {Object.values(FILTER_REFERENCES).map((f) => (
                      <SelectItem key={f.id} value={f.id}>
                        <div className="flex items-center gap-3">
                          <ImageThumb src={f.image} alt={f.label} size={34} />
                          <span>{f.label}</span>
                        </div>
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>

                {/* Photo + infos selection */}
                <div className="mt-2 flex items-start gap-3">
                  <ImageThumb src={filter.image} alt={filter.label} size={56} />
                  <div className="text-xs text-muted-foreground">
                    <div className="font-medium text-foreground/90">{filter.label}</div>
                    Poids neuf brut: <span className="font-medium">{filter.poidsNeufBrutKg.toFixed(2)} kg</span> · Charbon net:{" "}
                    <span className="font-medium">{filter.poidsCharbonNetKg.toFixed(2)} kg</span> · Support:{" "}
                    <span className="font-medium">{formatKg(supportKg)}</span>
                  </div>
                </div>

                <div className="text-xs text-muted-foreground">
                  Images: place-les dans <span className="font-medium">/public/products/</span> (ex: can1500.jpg). Si une image manque, elle se masque.
                </div>
              </div>

              <div className="space-y-2">
                <Label>Mode</Label>
                <Select value={mode} onValueChange={(v) => setMode(v as ModePolluant)}>
                  <SelectTrigger className="rounded-2xl">
                    <SelectValue placeholder="Mode" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="mono">1 polluant</SelectItem>
                    <SelectItem value="melange">Melange de polluants</SelectItem>
                  </SelectContent>
                </Select>
                <div className="text-xs text-muted-foreground">
                  En mode melange, la decision est basee sur le calcul <span className="font-medium">conservateur</span>.
                </div>
              </div>

              <div className="space-y-2 md:col-span-2">
                <Label>Recherche polluant</Label>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-2">
                  <div className="md:col-span-1">
                    <Select value={groupFilter} onValueChange={(v) => setGroupFilter(v as any)}>
                      <SelectTrigger className="rounded-2xl">
                        <SelectValue placeholder="Groupe" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="ALL">Tous les groupes</SelectItem>
                        <SelectItem value="1">Groupe 1</SelectItem>
                        <SelectItem value="2">Groupe 2</SelectItem>
                        <SelectItem value="3">Groupe 3</SelectItem>
                        <SelectItem value="4">Groupe 4</SelectItem>
                      </SelectContent>
                    </Select>
                  </div>

                  <div className="md:col-span-2 relative">
                    <Input
                      className="rounded-2xl"
                      placeholder="Rechercher un polluant..."
                      value={polluantSearch}
                      onChange={(e) => setPolluantSearch(e.target.value)}
                    />

                    {polluantSearch.trim().length > 0 && (
                      <div className="absolute z-50 mt-2 w-full rounded-2xl border bg-background shadow-sm overflow-hidden">
                        {filteredPolluants.length === 0 ? (
                          <div className="p-3 text-sm text-muted-foreground">Aucun resultat</div>
                        ) : (
                          <div className="max-h-64 overflow-auto">
                            {filteredPolluants.slice(0, 12).map((p) => (
                              <button
                                key={p.id}
                                type="button"
                                className="w-full text-left px-3 py-2 text-sm hover:bg-muted"
                                onClick={() => {
                                  if (mode === "mono") {
                                    setPolluantId(p.id);
                                  } else {
                                    setMixItems((prev) => {
                                      const next = [...prev];
                                      const emptyIdx = next.findIndex((x) => !x.polluantId);
                                      if (emptyIdx >= 0) next[emptyIdx] = { ...next[emptyIdx], polluantId: p.id };
                                      else next[next.length - 1] = { ...next[next.length - 1], polluantId: p.id };
                                      return next;
                                    });
                                  }
                                  setPolluantSearch("");
                                }}
                              >
                                <div className="font-medium">{displayPolluant(p)}</div>
                                <div className="text-xs text-muted-foreground">
                                  {(GROUPS[p.group].avg * 100).toFixed(0)}% · {GROUPS[p.group].label}
                                </div>
                              </button>
                            ))}
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                </div>
              </div>

              {mode === "mono" ? (
                <div className="space-y-2 md:col-span-2">
                  <Label>Polluant</Label>
                  <Select value={polluantId} onValueChange={(v) => setPolluantId(v)}>
                    <SelectTrigger className="rounded-2xl">
                      <SelectValue placeholder="Selectionner un polluant" />
                    </SelectTrigger>
                    <SelectContent>
                      {polluantsForSelect.map((p) => (
                        <SelectItem key={p.id} value={p.id}>
                          {`G${p.group} - ${displayPolluant(p)}`}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                  <div className="text-xs text-muted-foreground">
                    {GROUPS[polluant.group].label} · capacite moyenne appliquee:{" "}
                    <span className="font-medium">{(GROUPS[polluant.group].avg * 100).toFixed(0)}%</span>
                  </div>
                </div>
              ) : (
                <div className="space-y-3 md:col-span-2">
                  <div className="space-y-1">
                    <Label>Melange (option: % de chaque polluant)</Label>
                    <div className="text-xs text-muted-foreground">
                      Si les % sont vides, on suppose des parts egales. La decision de remplacement utilise le <span className="font-medium">pire cas</span>.
                    </div>
                  </div>

                  <Card className="rounded-2xl">
                    <CardContent className="p-4 space-y-2">
                      <div className="text-sm font-medium flex items-center gap-2">
                        <Sparkles className="h-4 w-4" />
                        Je ne sais pas (profil)
                      </div>
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-2">
                        <div className="md:col-span-2">
                          <Select value={mixPresetId} onValueChange={(v) => setMixPresetId(v)}>
                            <SelectTrigger className="rounded-2xl">
                              <SelectValue placeholder="Choisir un profil" />
                            </SelectTrigger>
                            <SelectContent>
                              {MIX_PRESETS.map((p) => (
                                <SelectItem key={p.id} value={p.id}>
                                  {p.label}
                                </SelectItem>
                              ))}
                            </SelectContent>
                          </Select>
                        </div>
                        <Button type="button" className="rounded-2xl" onClick={applyPreset}>
                          Appliquer
                        </Button>
                      </div>
                      <div className="text-xs text-muted-foreground">
                        {MIX_PRESETS.find((p) => p.id === mixPresetId)?.note ?? ""}
                      </div>
                    </CardContent>
                  </Card>

                  <div className="space-y-2">
                    {mixItems.map((it, idx) => {
                      const p = POLLUANTS.find((x) => x.id === it.polluantId) ?? null;
                      return (
                        <div key={idx} className="grid grid-cols-1 md:grid-cols-6 gap-2 items-center">
                          <div className="md:col-span-4">
                            <Select
                              value={it.polluantId}
                              onValueChange={(v) =>
                                setMixItems((prev) => {
                                  const next = [...prev];
                                  next[idx] = { ...next[idx], polluantId: v };
                                  return next;
                                })
                              }
                            >
                              <SelectTrigger className="rounded-2xl">
                                <SelectValue placeholder="Selectionner un polluant" />
                              </SelectTrigger>
                              <SelectContent>
                                {polluantsForSelect.map((pp) => (
                                  <SelectItem key={`${pp.id}__${idx}`} value={pp.id}>
                                    {`G${pp.group} - ${displayPolluant(pp)}`}
                                  </SelectItem>
                                ))}
                              </SelectContent>
                            </Select>
                            {p && (
                              <div className="text-xs text-muted-foreground mt-1">
                                {GROUPS[p.group].label} · {(GROUPS[p.group].avg * 100).toFixed(0)}%
                              </div>
                            )}
                          </div>

                          <div className="md:col-span-1">
                            <Input
                              className="rounded-2xl"
                              inputMode="decimal"
                              placeholder="%"
                              value={it.sharePct}
                              onChange={(e) =>
                                setMixItems((prev) => {
                                  const next = [...prev];
                                  next[idx] = { ...next[idx], sharePct: e.target.value };
                                  return next;
                                })
                              }
                            />
                          </div>

                          <div className="md:col-span-1 flex gap-2 justify-end">
                            <Button
                              type="button"
                              variant="outline"
                              className="rounded-2xl"
                              onClick={() => setMixItems((prev) => prev.filter((_, i) => i !== idx))}
                              disabled={mixItems.length <= 1}
                            >
                              Retirer
                            </Button>
                          </div>
                        </div>
                      );
                    })}

                    <div className="flex flex-wrap gap-2">
                      <Button
                        type="button"
                        variant="outline"
                        className="rounded-2xl"
                        onClick={() => setMixItems((prev) => [...prev, { polluantId: "", sharePct: "" }])}
                      >
                        Ajouter un polluant
                      </Button>
                      <Button
                        type="button"
                        variant="outline"
                        className="rounded-2xl"
                        onClick={() => setMixItems((prev) => prev.map((x) => ({ ...x, sharePct: "" })))}
                      >
                        Effacer les %
                      </Button>
                    </div>
                  </div>
                </div>
              )}

              <div className="space-y-2">
                <Label>Poids brut mesure (kg)</Label>
                <Input
                  className="rounded-2xl"
                  inputMode="decimal"
                  placeholder="Ex: 8,30"
                  value={poidsMesureStr}
                  onChange={(e) => setPoidsMesureStr(e.target.value)}
                />
                <div className="text-xs text-muted-foreground">Saisie acceptee avec virgule ou point.</div>
              </div>

              <div className="grid grid-cols-2 gap-3">
                <div className="space-y-2">
                  <Label>Humidite (%)</Label>
                  <Input
                    className="rounded-2xl"
                    inputMode="decimal"
                    placeholder="Optionnel"
                    value={humiditeStr}
                    onChange={(e) => setHumiditeStr(e.target.value)}
                  />
                </div>
                <div className="space-y-2">
                  <Label>Temperature (C)</Label>
                  <Input
                    className="rounded-2xl"
                    inputMode="decimal"
                    placeholder="Optionnel"
                    value={temperatureStr}
                    onChange={(e) => setTemperatureStr(e.target.value)}
                  />
                </div>
              </div>

              <div className="space-y-2 md:col-span-2">
                <Label>Infos rapport (optionnel)</Label>
                <div className="grid grid-cols-1 md:grid-cols-4 gap-2">
                  <Input
                    className="rounded-2xl"
                    placeholder="Nom du client"
                    value={clientName}
                    onChange={(e) => setClientName(e.target.value)}
                  />
                  <Input
                    className="rounded-2xl"
                    placeholder="Operateur"
                    value={operatorName}
                    onChange={(e) => setOperatorName(e.target.value)}
                  />
                  <Input
                    className="rounded-2xl"
                    placeholder="SN appareil"
                    value={deviceSerial}
                    onChange={(e) => setDeviceSerial(e.target.value)}
                  />
                  <Input
                    className="rounded-2xl"
                    placeholder="Date (YYYY-MM-DD)"
                    value={reportDate}
                    onChange={(e) => setReportDate(e.target.value)}
                  />
                </div>
                <div className="text-xs text-muted-foreground">Ces champs sont inclus dans le rapport si renseignes.</div>
              </div>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
              <Card className="rounded-2xl">
                <CardContent className="p-4">
                  <div className="text-xs text-muted-foreground">Gain (adsorption)</div>
                  <div className="text-2xl font-semibold">{formatKg(gain)}</div>
                  <div className="text-xs text-muted-foreground mt-1">gain = poids mesure - poids neuf</div>
                </CardContent>
              </Card>

              <Card className="rounded-2xl">
                <CardContent className="p-4">
                  <div className="text-xs text-muted-foreground">Capacite max (pour decision)</div>
                  <div className="text-2xl font-semibold">{formatKg(activeCapaciteMax)}</div>
                  <div className="text-xs text-muted-foreground mt-1">
                    {mode === "mono" ? "charbon net x capacite moyenne" : "charbon net x capacite (pire cas)"}
                  </div>
                </CardContent>
              </Card>

              <Card className="rounded-2xl">
                <CardContent className="p-4">
                  <div className="flex items-center justify-between gap-2">
                    <div>
                      <div className="text-xs text-muted-foreground">Saturation (pour decision)</div>
                      <div className="text-2xl font-semibold">{formatPct(saturationClamped)}</div>
                    </div>
                    <Badge variant={status.tone} className="rounded-xl flex items-center gap-1">
                      <StatusIcon className="h-4 w-4" />
                      {status.label}
                    </Badge>
                  </div>
                  <div className="text-xs text-muted-foreground mt-1">(gain / capacite max) x 100</div>
                </CardContent>
              </Card>
            </div>

            {mode === "melange" && (
              <Card className="rounded-2xl">
                <CardContent className="p-4 space-y-2">
                  <div className="text-sm font-medium">Details melange</div>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <div className="rounded-xl border p-3">
                      <div className="text-xs text-muted-foreground">Estimation (parts / %)</div>
                      <div className="text-lg font-semibold">{formatPct(clamp(mixResult.estimated.saturationPct, 0, 500))}</div>
                      <div className="text-xs text-muted-foreground">avg utilise: {(mixResult.estimated.avgUsed * 100).toFixed(1)}%</div>
                      <div className="text-xs text-muted-foreground">capacite: {formatKg(mixResult.estimated.capaciteMaxKg)}</div>
                    </div>
                    <div className="rounded-xl border p-3">
                      <div className="text-xs text-muted-foreground">Conservateur (pire cas)</div>
                      <div className="text-lg font-semibold">{formatPct(clamp(mixResult.conservative.saturationPct, 0, 500))}</div>
                      <div className="text-xs text-muted-foreground">avg critique: {(mixResult.conservative.avgUsed * 100).toFixed(1)}%</div>
                      <div className="text-xs text-muted-foreground">capacite: {formatKg(mixResult.conservative.capaciteMaxKg)}</div>
                    </div>
                  </div>
                  <div className="text-xs text-muted-foreground">La valeur "Conservateur" est celle utilisee pour le badge et la decision (c'est la plus sure).</div>
                </CardContent>
              </Card>
            )}

            {warnings.length > 0 && (
              <Card className="rounded-2xl border-yellow-500/30">
                <CardContent className="p-4 space-y-2">
                  <div className="flex items-center gap-2 text-sm font-medium">
                    <AlertTriangle className="h-4 w-4" />
                    Points d'attention
                  </div>
                  <ul className="list-disc pl-5 text-sm text-muted-foreground space-y-1">
                    {warnings.map((w, i) => (
                      <li key={i}>{w}</li>
                    ))}
                  </ul>
                </CardContent>
              </Card>
            )}

            <div className="flex flex-col md:flex-row gap-2 md:items-center md:justify-between">
              <div className="text-xs text-muted-foreground">
                Seuils recommandes: OK &lt; 70% · A surveiller 70-75% · A remplacer a partir de 75% · Sature a partir de 100%
              </div>
              <div className="flex gap-2 items-center">
                <Button variant="outline" className="rounded-2xl" onClick={copyReport}>
                  <Copy className="h-4 w-4 mr-2" />
                  Copier rapport
                </Button>
                {copiedState === "copied" && <span className="text-xs text-muted-foreground">Copie OK</span>}
                {copiedState === "failed" && (
                  <span className="text-xs text-muted-foreground">Copie bloquee - champ manuel affiche</span>
                )}

                <Button variant="outline" className="rounded-2xl" onClick={reset}>
                  <RefreshCw className="h-4 w-4 mr-2" />
                  Reinitialiser
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>

        <Card className="rounded-2xl shadow-sm">
          <CardContent className="p-4 md:p-6 space-y-2">
            <div className="text-sm font-medium">Ameliorations possibles</div>
            <ul className="list-disc pl-5 text-sm text-muted-foreground space-y-1">
              <li>Ajouter numero de serie / site client / operateur pour fiabiliser le rapport.</li>
              <li>Ajouter un export fichier (TXT/PDF) si l'environnement le permet.</li>
              <li>Ajouter un indicateur d'humidite de fonctionnement (si capteur dispo) pour mieux expliquer les ecarts.</li>
            </ul>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
